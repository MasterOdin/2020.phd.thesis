\section{The Cognitive Event Calculus}

%TODO:
%   1. go through and expand CEC
%   2. remove duplicate tables of syntax/sorts
%   3. Add subsection on shadowprover

To capture the CAIS in a formal way, we employ the
\textbf{cognitive event calculus} (\CEC), a cognitive calculus and
intensional logic, which provides a subset of the \DCEC~\cite{nsg_sb_dde_ijcai}.
The \CEC\ is a multi-sorted
quantified modal logic with a well-defined syntax and proof calculus.
\CEC\ subsumes the event calculus~\cite{mueller_commonsense_2014}, a first-order
calculus used for modeling events and actions and their effects upon
the world.  The proof calculus of \CEC\ is based on natural deduction
\cite{gentzen_investigations_1964} and includes all the introduction and elimination
rules for first-order logic, as well as inference schemata for the
modal operators and related structures.  \CEC\ is a sorted system and
includes the built-in sorts shown in Table~\ref{syn:sorts}.

Table~\ref{syn:terms} presents the syntax of our language for forming
terms, while Table~\ref{syn:defs} presents a list of built-in function
symbols, which come from the standard event calculus, in our language.
Table~\ref{syn:formulae} shows the syntax for
formulae in the language, and finally Table~\ref{rules} shows a subset of
inference schemata needed for our current purpose. The main
inference schemata needed include $I_{\knows}$ and $I_{\believes}$,
which state that knowledge and belief are closed under the inference
system of \CEC.  We also have inference schemata that let us go
from perception to knowledge ($I_1$), knowledge to belief ($I_2$),
common knowledge to knowledge ($I_3$), and from knowledge to
propositions that hold ($I_4$). Below, we also use \emph{derived
  inference schemata} for converting perceptions to knowledge,
knowledge to belief, common knowledge to belief,~labeled as
$D_{[\perceives \leadsto \knows]}$, $D_{[\knows \leadsto \believes]}$,
and $D_{[\common \leadsto \believes]}$ respectively
\cite{ArkoudasAndBringsjord2008Pricai}.

\begin{table}
\begin{footnotesize}
\begin{center}

\begin{tabular}{lp{8cm}}
\toprule
\textbf{Sort}    & \textbf{Description} \\
\midrule
\type{Agent} & Human and non-human actors.  \\

\type{Moment} &  Time points. E.g., $t_i$, $birthday(son(jack))$ etc. \\

  \type{Event} & Used for events in the domain. \\
  \type{ActionType} & Abstract actions
                      instantiated by agents.\\
  \type{Action} & Events that occur
                  as actions by agents \\
  \type{Fluent} & Representing states of the world.\\
  \type{Formula} & Represents any arbitrary formula\\
  \bottomrule
\end{tabular}
\caption{Basic sorts in the language}
\label{syn:sorts}
\end{center}
\end{footnotesize}
\end{table}


\begin{figure}[ht!]
% frametitle=Signature (snippet), 
\begin{mdframed}[roundcorner=8pt, nobreak=true, frametitlealignment=\centering]
\begin{equation*}
 \begin{aligned}
    \mathit{S} &::= 
    \left\{\begin{aligned}
      & \Object \sep \Agent  \sep \ActionType \sep \Action \sqsubseteq
      \Event \sep \\ &\Moment  \sep \Fluent \sep \Numeric\\
    \end{aligned} \right.
    \\ 
    \hspace{-29pt}\mathit{f} &::= \left\{
    \begin{aligned}
      & \action: \Agent \times \ActionType \rightarrow \Action \\
      &  \initially: \Fluent \rightarrow \Boolean\\
      &  \holds: \Fluent \times \Moment \rightarrow \Boolean \\
      & \happens: \Event \times \Moment \rightarrow \Boolean \\
      & \clipped: \Moment \times \Fluent \times \Moment \rightarrow \Boolean \\
      & \initiates: \Event \times \Fluent \times \Moment \rightarrow \Boolean\\
%      & \terminates: \Event \times \Fluent \times \Moment \rightarrow \Boolean \\
      & \prior: \Moment \times \Moment \rightarrow \Boolean\\
    \end{aligned}\right.\\
        \mathit{t} &::=
    \begin{aligned}
      \mathit{x : S} \sep \mathit{c : S} \sep f(t_1,\ldots,t_n)
    \end{aligned}
    \\ 
    \mathit{\phi}&::= \left\{ 
    \begin{aligned}
     & 
        A(\ldots):\Boolean \sep 
        \neg \phi \sep
        \phi \land \psi \sep
        \phi \lor \psi \sep \\
    &
        \phi \lif \psi \sep
        \phi \liff \psi \sep
        \exists x \phi(x) \sep
        \forall x \phi(x)\\
     &
        \perceives (a,t,\phi)  \sep
        \knows(a,t,\phi) \sep
        \common(t,\phi) \sep
        \believes(a,t,\phi) \\
    &
        \says(a,t,\phi) \sep
        \says(a,b,t,\phi)  \sep
        \desires(a,t,\phi) \sep
        \intends(a,t,\phi) \\
      \end{aligned}\right.
  \end{aligned}
\end{equation*}
\end{mdframed}
\caption{\CEC\ Syntax}
\label{sig}
\end{figure}

%% Moved the the tables for syntax, formula, and schema into the middle of
%% the reasoner-planner section
%% to force latex to put them onto the same page and save some space // Matt

To handle reasoning within \CEC\, we utilize a quantified modal logic
theorem prover, \textsf{ShadowProver}, first presented in
\cite{nsg_sb_dde_ijcai,uncertaintyized_cognitive_calculus}.\footnote{The
  prover is available in both Java and Common Lisp and can be obtained
  at: \url{https://github.com/naveensundarg/prover}. The underlying
  first-order prover is SNARK, available at:
  \url{http://www.ai.sri.com/~stickel/snark.html}.}  The prover works
by utilizing a technique called \textbf{shadowing} to achieve speed
without sacrificing consistency in the system.  Shadowing is a
syntactic operation that converts any modal formula (or a set of
formulae) $\phi$ to a non-modal formula $\mathsf{shadow}[\phi]$ by replacing atomic
modal sub-formuale with propositional atoms.


\begin{figure}[ht!]
% frametitle=Inference Schemata (snippet),
\begin{mdframed}[nobreak=true, roundcorner=8pt, frametitlealignment=\centering]
\begin{equation*}
\begin{aligned}
% &\mbox{Sample rules below. For more rules, see
%   \cite{akratic_robots_ieee_n}.}\\
  &\infer[{[R_{\knows}]}]{\knows(a,t_2,\phi)}{\knows(a,t_1,\Gamma), \ 
    \ \Gamma\vdash\phi, \ \ t_1 \leq t_2} \\ 
& \infer[{[R_{\believes}]}]{\believes(a,t_2,\phi)}{\believes(a,t_1,\Gamma), \ 
    \ \Gamma\vdash\phi, \ \ t_1 \leq t_2} \\
 &\infer[{[R_1]}]{\common(t,\perceives(a,t,\phi) \lif\knows(a,t,\phi))}{}\\
&  \infer[{[R_2]}]{\common(t,\knows(a,t,\phi)
    \lif\believes(a,t,\phi))}{}\\
  &\infer[{[R_3]}]{\knows(a_1, t_1, \ldots
    \knows(a_n,t_n,\phi)\ldots)}{\common(t,\phi) \ t\leq t_1 \ldots t\leq
    t_n}\hspace{10pt}
  \infer[{[R_4]}]{\phi}{\knows(a,t,\phi)}\\
  & \infer[{[R_5]}]{\common(t,\knows(a,t_1,\phi_1\lif\phi_2))
    \lif \knows(a,t_2,\phi_1) \lif \knows(a,t_3,\phi_2)}{}\\
& \infer[{[R_6]}]{\common(t,\believes(a,t_1,\phi_1\lif\phi_2))
    \lif \believes(a,t_2,\phi_1) \lif \believes(a,t_3,\phi_2)}{}\\
& \infer[{[R_7]}]{\common(t,\common(t_1,\phi_1\lif\phi_2))
    \lif \common(t_2,\phi_1) \lif \common(t_3,\phi_2)}{} \\
& \infer[{[R_8]}]{\common(t, \forall x. \  \phi \lif \phi[x\mapsto
  t])}{} \hspace{18pt}
  \infer[{[R_9]}]{\common(t,\phi_1 \liff \phi_2 \lif \neg
    \phi_2 \lif \neg \phi_1)}{}\\
& \infer[{[R_{10}]}] {\common(t,[\phi_1\land\ldots\land\phi_n\lif\phi]
  \lif [\phi_1\lif\ldots\lif\phi_n\lif\psi])}{}\\
% & \infer[{[R_{11a}]}]{\believes(a,t,\psi)}{\believes(a,t,\phi)\ \ \phi
%   \lif \psi}\
%\hspace{6pt} \infer[{[R_{11b}]}]{\believes(a,t,\psi \land \phi)}{\believes(a,t,\phi)\ \ \believes(a,t,\psi)}\\ 
&\infer[{[R_{12}]}]{\believes(h,t,\believes(s,t,\phi))}{\says(s,h,t,\phi)}
\\ &\infer[{[R_{13}]}]{\perceives(a,t,\happens(\action(a^\ast,\alpha),t))}{\intends(a,t,\happens(\action(a^\ast,\alpha),t'))}
\end{aligned}
\end{equation*}
\end{mdframed}
%\end{scriptsize}
\caption{\CEC Inference Schemata}
\label{infschem}
\end{figure}

The prover can be equipped
with multiple sets of inference schemes $\rho^p_{q}$, where
$q\in\mathbb{N}$ denotes the degree of the schemes (e.g. $0$ for
propositional schemes, $1$ for first-order quantifier schemes, etc.)
and $p\in\{0,1\}$ denotes the modality of the schemes. For example, pure
propositional logic and first-order schemes are given by $\rho^0_{0}$
and $\rho^0_{1}$, while modal
propositional or modal first-order schemas are given by $\rho^1_{0}$ and
$\rho^1_{1}$.


% Given any arbitrary formula $\phi$, $\mathsf{A}_{[\phi]}$ is a unique
% atomic (propositional) symbol. We define the \textsf{level} of a
% formula: $\mathsf{level}(\phi) = 0$ if $\phi$ is purely propositional;
% $\mathsf{level} (\phi) = 1$ if $\phi$ is purely first-order; and
% $\mathsf{level} (\phi) = 2$ if $\phi$ is modal.  Given the above
% definition, we can define the operation of \textbf{shadowing} a
% formula to a level.  To shadow a formula $\chi$ to a level $l$,
% replace all subformulae $\chi'$ in $\chi$ such that
% $\mathsf{level}(\chi')>l$ with $\mathsf{A}_{[\chi']}$
% simultaneously. We denote this by $\mathsf{S}[\phi,l]$.
Starting from a set of modal formula $\Gamma$ as premises and a goal
$\phi$, the prover operates in two phases. In the first phase, it
expands $\Gamma$ using the modal schemes $\rho^1_{0}$ and
$\rho^1_{1}, $ and checks if $\phi$ is contained in the expanded
set. In the second phase, the prover applies the non-modal schemes
$\rho^0_{0} $ and $\rho^0_{1}$ to $\mathsf{shadow}[\Gamma]$ and checks whether
the expanded set contains $\mathsf{shadow}[\phi]$. The two phases are repeated
till either the goal is reached or no expansions happen.

Planning for the room is handled by \textsf{Spectra}, a planner based
on an \emph{extension} of the STRIPS-style
planning language, and backed by \textsf{ShadowProver}. In this planning formalism, arbitrary
formulae of \CEC\ are allowed in states, actions, and goals.  For
instance, valid states and goals can include: \emph{``No three blocks
on the table should be of the same color.''}  and \emph{``Jack
believes that Jill believes there is one block on the table.''}

\begin{comment}
\subsection{Non-modal Systems are not Enough}
\label{sect:prop_not_enough}
 In an \textbf{extensional} system, two
terms $t_1$ and $t_2$ are considered to be identical if they denote
the same set of objects. Logics such as propositional logic,
first-order logic, higher-order logic, etc. are extensional systems
and are best suited to modeling states of the world. In an
\textbf{intensional} system, the meaning of a term $t$ is dependent on
the context $C$ in which it occurs. Modal logics are intensional
systems. \CEC\ is an {intensional} logic in the sense that it has
intensional operators.\footnote{Please note that there is a vast difference between
  intension and intention.} Intensional systems are crucial for modeling
theory-of-mind reasoning.

For example, using an extensional system such as first-order logic to
model theory-of-mind reasoning leads to unsound inferences as shown
below, in which we have an agent $r$ that knows the manager of a team
is the most responsible person in the team.  Agent $r$ does not know
that $\mathit{Moe}$ is the manager of the team, but it's true that
$\mathit{Moe}$ is the manager.  If the knowledge operator $\mathbf{K}$
is a simple first-order predicate, we get the proof shown below, which
produces a contradiction (that $r$ knows that $\mathit{Moe}$ is the
manager) from true premises.  This unsoundness persists even with more
robust representation schemes in extensional logics
\cite{selmer_naveen_metaphil_web_intelligence}.

\vspace{10pt}

\begin{minipage}[b]{0.7\textwidth}
\begin{footnotesize}
 \begin{footnotesize}
\begin{equation*}
\begin{aligned}
&\fbox{1}\ \ \mathbf{K}\left(r,\
  \mathsf{Manager}\left(\mathit{team}, \mathit{mostResponsible}\left(\mathit{team}\right) \right)\right) \mbox{
  {\color{gray}; given}} \\
&\fbox{2}\ \ \lnot \mathbf{K}\left(r,\mathsf{Manager}\left(\mathit{team}, \mathit{Moe}\right)\right) \mbox{
  {\color{gray}; given}}\\
&\fbox{3}\ \ \mathit{Moe} = \mathit{mostResponsible}\left(\mathit{team}\right)  \mbox{
  {\color{gray}; given}}\\
&\fbox{4}\ \ \mathbf{K}\left(r,\mathsf{Manager}\left(\mathit{team}, \mathit{Moe}\right)\right)  \mbox{
  {\color{gray}; first-order inference from \fbox{3} and \fbox{1}}}\\
& \fbox{5}\ \ \mathbf{\bot}  \mbox{
  {\color{gray}; first-order inference from \fbox{4} and \fbox{2}}}
\end{aligned}
\end{equation*}
\end{footnotesize}
\end{footnotesize}
\end{minipage}
\end{comment}
